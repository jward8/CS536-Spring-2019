<html>
<head>
<link rel="stylesheet" href="dextras.css" />

<script type="text/x-mathjax-config">
    // <![CDATA[
    MathJax.Hub.Config({
        TeX: {extensions: ["AMSmath.js", "AMSsymbols.js"]},
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        showProcessingMessages : false,
        messageStyle : "none" ,
        showMathMenu: false ,
        tex2jax: {
            processEnvironments: true,
            inlineMath: [ ['$','$'] ],
            displayMath: [ ['$$','$$'] ],
            preview : "none",
            processEscapes: true
        },
        "HTML-CSS": { linebreaks: { automatic:true, width: "latex-container"} }
    });
    // ]]>
 // MathJax.Hub.Queue(reportReload);
</script>
<script type="text/javascript" src="MathJax.js"></script>
<script type="text/javascript" src="latex2html5.min.js"></script>


</head>
<body>
<A NAME=top></a>
<HR>
<H2>Contents</H2>
  <LI><A HREF="#overview">Overview</A>
  <LI><A HREF="#spim">Spim</A>
  <LI><A HREF="#aux">Auxiliary Fields and Methods</A>
  <LI><A HREF="#globals">Code Generation for Global Variable Declarations</A>
  <LI><A HREF="#functions">Code Generation for Functions</A>
    <UL>
      <LI><A HREF="#functionPreamble">Function Preamble</A>
      <LI><A HREF="#functionEntry">Function Entry</A>
      <LI><A HREF="#functionBody">Function Body</A>
      <LI><A HREF="#functionReturn">Function Exit</A>
    </UL>
  <LI><A HREF="#stmts">Code Generation for Statements</A>
    <UL>
      <LI><A HREF="#printstmt">Write Statement</A>
      <LI><A HREF="#if">If-Then Statement</A>
        <UL>
        <LI><A HREF="#youtry1">Test Yourself #1</A>
	</UL>
      <LI><A HREF="#return">Return Statement</A>
      <LI><A HREF="#read">Read Statement</A>
      <LI><A HREF="#names">Digression: Code Generation for IdNodes</A>
        <UL>
	 <LI><A HREF="#jal">genJumpAndLink</A>
	 <LI><A HREF="#codeGen">codeGen</A>
	 <LI><A HREF="#genAddr">genAddr</A>
	</UL>
      <LI><A HREF="#assign">Assignment Statement</A>
    </UL>
  <LI><A HREF="#exps">Code Generation for Expressions</A>
    <UL>
      <LI><A HREF="#assignExp">Assign</A>
      <LI><A HREF="#literals">Literals</A>
      <LI><A HREF="#call">Function Call</A>
      <LI><A HREF="#arith">Non Short-Circuited Operators</A>
      <LI><A HREF="#logic">Short-Circuited Operators</A>
        <UL>
        <LI><A HREF="#youtry2">Test Yourself #2</A>
	</UL>
    </UL>
  <LI><A HREF="#jumpcode">Control-Flow Code</A>
        <UL>
        <LI><A HREF="#youtry3">Test Yourself #3</A>
        <LI><A HREF="#youtry4">Test Yourself #4</A>
	</UL>
<UL>
</UL>

<P>
<a name=overview></a>
<span class=subhead>Overview</span>
<P>
Code can be generated by a syntax-directed translation while parsing
or by traversing the abstract syntax tree after the parse (i.e., by writing
a codeGen method for the appropriate kinds of AST nodes).

We will assume the latter approach, and will discuss code generation
for a subset of the C language.
In particular, we will discuss generating MIPS
assembly code suitable for input to the Spim interpreter.

Some information on Spim is provided in the next section;
the following sections discuss code generation for:
<UL>
  <LI> global variables
  <LI> functions (entry and exit)
  <LI> statements
  <LI> expressions
</UL>

<a name=spim></a>
<span class=subhead>Spim</span>
<P>
Documentation on Spim is available on-line:
<UL>
      <LI> <A HREF="http://www.cs.wisc.edu/~horwitz/spim/spim.pdf">
            Reference Manual (pdf)</A>
      <LI> <A HREF="http://www.cs.wisc.edu/~larus/spim.html">
            Instructions for download and install (html)</A>
</UL>
<P>
To run the (plain) Spim interpreter, type:
<UL><tt>spim -file &lt;name&gt;</tt></UL>
where <tt>&lt;name&gt;</tt> is the name of a file that contains MIPS
assembly code (the file produced by your compiler).
This will cause Spim to process the code in the file;
if there are syntax errors, they will be reported, and the code
will not execute.
Otherwise, the code will execute;
output will be printed to your terminal, and you will get error messages for
any run-time errors that result.
<P>
To run Spim with an X-windows interface (on a Linux machine),
type just: <tt>xspim</tt>.
This will cause a window to open.
Click on the <tt>load</tt> button in that window, then type in the
name of your assembly-code file, then press <tt>return</tt>.
If there are syntax errors, you will see error messages.
If there are no errors, you can run your program by clicking on
<tt>run</tt>, then (in the small window that will be opened)
on <tt>OK</tt>.
If your program generates any output, a new window will be opened
to display that output.
<P>
Spim uses the following special registers (there are others;
you can see the on-line Spim documentation for those, but you
should not need them for the class project):
<P>
<CENTER><TABLE BORDER >
<TR>
  <TD>
    <b>Register</b>
  </TD>
	<td style="padding-left:60px"></td>
  <TD>
    <b>Purpose</b>
  </TD>
</TR>
<TR>
  <TD>\$sp </TD>
	<td></td>
  <TD>stack pointer </TD>
</TR>
<TR>
  <TD>\$fp</TD>
	<td></td>
  <TD>frame pointer</TD>
</TR>
<TR>
  <TD>\$ra</TD>
	<td></td>
  <TD>return address </TD>
</TR>
<TR>
  <TD>\$v0  </TD>
	<td></td>
  <TD>used for system calls and to return int values from function calls, including the syscall that reads an int </TD>
</TR>
<TR>
  <TD>\$f0  </TD>
	<td></td>
  <TD>used to return double values from function calls, including the syscall that reads a double </TD>
</TR>
<TR>
  <TD>\$a0  </TD>
	<td></td>
  <TD>used for output of int and string values </TD>
</TR>
<TR>
  <TD>\$f12  </TD>
	<td></td>
  <TD>used for output of double values </TD>
</TR>
<TR>
  <TD>\$t0 - \$t7  </TD>
	<td></td>
  <TD>temporaries for ints </TD>
</TR>
<TR>
  <TD>\$f0 - $f30  </TD>
	<td></td>
  <TD>registers for doubles (used in pairs; i.e., use \$f0 for the pair \$f0, \$f1)</TD>
</TR>
</TABLE></CENTER>

<P>
<a name=aux></a>
<span class=subhead>Auxiliary Constants and Methods</span>
<P>
To simplify the task of code generation, it is convenient to have a
set of constants (final static fields) that define the string
representations of the registers that will be used in the generated code
and the values used to represent <em>true</em> and <em>false</em>, as well
as a set of methods for actually writing the generated code to a file.
We will assume that we have the following register constants:
SP, FP, RA, V0, A0, T0, T1, F0, F12, as well as the constants TRUE and FALSE
(and that TRUE is represented as 1, and false as 0).
We will also assume that we have the following methods:
<P>
<CENTER><TABLE class=cfg>
<TR>
  <TD style="border-bottom: 1px solid"><b>Method</b></TD>
	<td style="padding-left:20px"></td>
  <TD style="border-bottom: 1px solid"><b>Purpose</b></TD>
</TR>
<TR>
  <TD>generate</TD>
	<td></td>
  <TD>
     write the given op code and arguments, nicely formatted, to the output
    file
  </TD>
</TR>
<TR>
  <TD>generateIndexed</TD>
	<td></td>
  <TD>
     the arguments are: an op code, a register R1, another register R2, and
     an offset; generate code of the form: <tt>op R1, offset(R2)</tt>
  </TD>
</TR>
<TR>
  <TD>genPush(String reg, int bytes)</TD>
	<td></td>
  <TD>
    generate code to push the value in the given register onto the stack;<br>
    parameter <tt>bytes</tt> is 4 for an int and 8 for a double
  </TD>
</TR>
<TR>
  <TD>genPop(String reg, int bytes)</TD>
	<td></td>
  <TD>
    generate code to pop the top-of-stack value into the given register
  </TD>
</TR>
<TR>
  <TD>nextLabel</TD>
	<td></td>
  <TD>
    return a string to be used as a label (more on this later)
  </TD>
<TR>
  <TD>genLabel</TD>
	<td></td>
  <TD>
    given a label L, generate: <tt>L:</tt>
  </TD>
</TR>
</TABLE></CENTER>

<a name=globals></a>
<span class=subhead>Code Generation for Global Variable Declarations</span>
<P>
For each global variable <tt>v</tt>, generate:
<pre>
	.data
	.align 2  # align on a word boundary
    _v: .space N
</pre>
where <tt>N</tt> is the size of the variable in bytes.
(Scalar integer variables require 4 bytes;
double variables require 8 bytes.)
This code tells the assembler to set aside N bytes in the static data
area, in a location labeled with the name <tt>_v</tt>.
<P>
<b>Example</b>:
Given this source code:
<pre>
	int x;
	double y;
</pre>
you should generate this code:
<pre>
	.data
	.align 2
    _x: .space 4
	.data
	.align 2
    _y: .space 8
</pre>
It is not actually necessary to generate <tt>.data</tt> if the
previous generated code was also for a global variable declaration;
however, since function declarations can be intermixed with global
variable declarations (and cause code to be generated in the text area, not
the static data area), this may not be the case;
it is safe (and easier) just to generate those directives for every global
variable.
<P>
<a name=functions></a>
<span class=subhead>Code Generation for Functions</span>
<P>
For every function you will generate code for:
<UL>
  <LI> the function "preamble"
  <LI> the function entry (to set up the function's Activation Record)
  <LI> the function body (its statements)
  <LI> function exit (restoring the stack, and returning to the caller).
</UL>

<P>
<a name="functionPreamble"></a>
<span class=subsubhead>Function Preamble</span>
<p>
For the <tt>main</tt> function, generate:
<pre>
	.text
	.globl main
   main:
</pre>
<P>
For all other functions, generate:
<pre>
        .text
        _&lt;functionName&gt;:
</pre>
using the actual name in place of <tt>&lt;functionName&gt;</tt>.
This tells the assembler to store the following instructions in the
text area, labeled with the given name.
<P>
After generating this "preamble" code,
you will generate code for (1) function entry, (2) function body, and
(3) function exit.
</p>

<P>
<a name="functionEntry"></a>
<span class=subsubhead>Function Entry</span>
<p>
We assume that when a function starts executing, the stack looks like this:
<div class=row>
	<div class=12u>
		<center>
		<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="338"
   height="207"
   id="svg2"
   version="1.1"
   inkscape:version="0.48.3.1 r9886"
   sodipodi:docname="codegen_call1.svg">
  <defs
     id="defs4">
    <marker
       inkscape:stockid="Arrow1Send"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow1Send"
       style="overflow:visible">
      <path
         id="path3814"
         d="M 0,0 5,-5 -12.5,0 5,5 0,0 z"
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt"
         transform="matrix(-0.2,0,0,-0.2,-1.2,0)"
         inkscape:connector-curvature="0" />
    </marker>
    <marker
       inkscape:stockid="Arrow1Mend"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow1Mend"
       style="overflow:visible">
      <path
         id="path3808"
         d="M 0,0 5,-5 -12.5,0 5,5 0,0 z"
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt"
         transform="matrix(-0.4,0,0,-0.4,-4,0)"
         inkscape:connector-curvature="0" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="1.1289063"
     inkscape:cx="217.29941"
     inkscape:cy="149.38587"
     inkscape:document-units="px"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="665"
     inkscape:window-height="724"
     inkscape:window-x="0"
     inkscape:window-y="0"
     inkscape:window-maximized="0"
     fit-margin-top="0"
     fit-margin-left="0"
     fit-margin-right="0"
     fit-margin-bottom="0" />
  <metadata
     id="metadata7">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(-73.810012,-146.3701)">
    <rect
       style="fill:none;stroke:#000000"
       id="rect2985"
       width="128.06078"
       height="98.641411"
       x="153.85368"
       y="252.2287"
       rx="0"
       ry="0" />
    <text
       xml:space="preserve"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:end;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:end;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       x="128.40573"
       y="297.36218"
       id="text3755"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan3757"
         x="133.39792"
         y="297.36218">caller's </tspan><tspan
         sodipodi:role="line"
         x="128.40573"
         y="319.86218"
         id="tspan3759">AR</tspan></text>
    <rect
       ry="0"
       rx="0"
       y="154.2287"
       x="153.85368"
       height="98.641411"
       width="128.06078"
       id="rect3761"
       style="fill:none;stroke:#000000" />
    <text
       xml:space="preserve"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       x="324"
       y="200.36218"
       id="text3763"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan3765"
         x="324"
         y="200.36218">parameters</tspan></text>
    <text
       xml:space="preserve"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       x="305"
       y="257.36218"
       id="text3767"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan3769"
         x="305"
         y="257.36218">FP</tspan></text>
    <text
       sodipodi:linespacing="125%"
       id="text3771"
       y="158.43829"
       x="309"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;opacity:0.82999998;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       xml:space="preserve"><tspan
         y="158.43829"
         x="309"
         id="tspan3773"
         sodipodi:role="line">SP</tspan></text>
    <path
       style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
       d="M 149.33458,257.58148 C 128.73734,261.00883 148.66611,288.38613 141.22899,297.87312 136.08231,303.0198 133.1234,301.87312 133.1234,301.87312"
       id="path3775"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       sodipodi:nodetypes="ccc"
       inkscape:connector-curvature="0"
       id="path3781"
       d="M 149.33458,346.33562 C 128.73734,342.90827 148.66611,315.53097 141.22899,306.04398 136.08231,300.8973 133.1234,302.04398 133.1234,302.04398"
       style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
    <g
       id="g3787"
       transform="translate(156,-101)">
      <path
         style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
         d="M 131.1234,348.33562 C 151.72064,344.90827 131.79187,317.53097 139.22899,308.04398 144.37567,302.8973 147.33458,304.04398 147.33458,304.04398"
         id="path3783"
         inkscape:connector-curvature="0"
         sodipodi:nodetypes="ccc" />
      <path
         sodipodi:nodetypes="ccc"
         inkscape:connector-curvature="0"
         id="path3785"
         d="M 131.1234,259.58148 C 151.72064,263.00883 131.79187,290.38613 139.22899,299.87312 144.37567,305.0198 147.33458,303.87312 147.33458,303.87312"
         style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
    </g>
    <path
       style="opacity:0.82999998;fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;marker-end:url(#Arrow1Mend)"
       d="M 307,152.4383 C 296.06116,158.40838 298.64887,150.768 284,153.3133"
       id="path3791"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;marker-end:url(#Arrow1Mend)"
       d="M 304,251.36218 C 294.28943,256.41264 292.83565,252.3401 285.05546,253.9809"
       id="path3793"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
  </g>
</svg>
		</center>
	</div>
</div>
Before starting to execute the statements in the function body,
we want it to look like this:
<div class=row>
	<div class=12u>
		<center>
		<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="350"
   height="398"
   id="svg2"
   version="1.1"
   inkscape:version="0.48.3.1 r9886"
   sodipodi:docname="codegen_call2.svg">
  <defs
     id="defs4">
    <marker
       inkscape:stockid="Arrow1Send"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow1Send"
       style="overflow:visible">
      <path
         id="path3814"
         d="M 0,0 5,-5 -12.5,0 5,5 0,0 z"
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt"
         transform="matrix(-0.2,0,0,-0.2,-1.2,0)"
         inkscape:connector-curvature="0" />
    </marker>
    <marker
       inkscape:stockid="Arrow1Mend"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow1Mend"
       style="overflow:visible">
      <path
         id="path3808"
         d="M 0,0 5,-5 -12.5,0 5,5 0,0 z"
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt"
         transform="matrix(-0.4,0,0,-0.4,-4,0)"
         inkscape:connector-curvature="0" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="0.56445312"
     inkscape:cx="59.602188"
     inkscape:cy="245.0793"
     inkscape:document-units="px"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="665"
     inkscape:window-height="724"
     inkscape:window-x="0"
     inkscape:window-y="1"
     inkscape:window-maximized="0"
     fit-margin-top="0"
     fit-margin-left="0"
     fit-margin-right="0"
     fit-margin-bottom="0" />
  <metadata
     id="metadata7">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(-73.810012,44.629899)">
    <rect
       style="fill:none;stroke:#000000"
       id="rect2985"
       width="128.06078"
       height="98.641411"
       x="153.85368"
       y="252.2287"
       rx="0"
       ry="0" />
    <text
       xml:space="preserve"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:end;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:end;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       x="128.40573"
       y="297.36218"
       id="text3755"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan3757"
         x="133.39792"
         y="297.36218">caller's </tspan><tspan
         sodipodi:role="line"
         x="128.40573"
         y="319.86218"
         id="tspan3759">AR</tspan></text>
    <rect
       ry="0"
       rx="0"
       y="154.2287"
       x="153.85368"
       height="98.641411"
       width="128.06078"
       id="rect3761"
       style="fill:none;stroke:#000000" />
    <text
       xml:space="preserve"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       x="312"
       y="202.36218"
       id="text3763"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan3765"
         x="312"
         y="202.36218">parameters</tspan></text>
    <text
       xml:space="preserve"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       x="305"
       y="257.36218"
       id="text3767"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan3769"
         x="305"
         y="257.36218">FP</tspan></text>
    <text
       sodipodi:linespacing="125%"
       id="text3771"
       y="-29.561699"
       x="309"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;opacity:0.82999998;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       xml:space="preserve"><tspan
         y="-29.561699"
         x="309"
         id="tspan3773"
         sodipodi:role="line">SP</tspan></text>
    <path
       style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
       d="M 149.33458,257.58148 C 128.73734,261.00883 148.66611,288.38613 141.22899,297.87312 136.08231,303.0198 133.1234,301.87312 133.1234,301.87312"
       id="path3775"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       sodipodi:nodetypes="ccc"
       inkscape:connector-curvature="0"
       id="path3781"
       d="M 149.33458,346.33562 C 128.73734,342.90827 148.66611,315.53097 141.22899,306.04398 136.08231,300.8973 133.1234,302.04398 133.1234,302.04398"
       style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
    <g
       id="g3787"
       transform="translate(156,-101)">
      <path
         style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
         d="M 131.1234,348.33562 C 151.72064,344.90827 131.79187,317.53097 139.22899,308.04398 144.37567,302.8973 147.33458,304.04398 147.33458,304.04398"
         id="path3783"
         inkscape:connector-curvature="0"
         sodipodi:nodetypes="ccc" />
      <path
         sodipodi:nodetypes="ccc"
         inkscape:connector-curvature="0"
         id="path3785"
         d="M 131.1234,259.58148 C 151.72064,263.00883 131.79187,290.38613 139.22899,299.87312 144.37567,305.0198 147.33458,303.87312 147.33458,303.87312"
         style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
    </g>
    <path
       style="opacity:0.82999998;fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;marker-end:url(#Arrow1Mend)"
       d="M 307,-35.561702 C 296.06116,-29.591622 298.64887,-37.232002 284,-34.686702"
       id="path3791"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;marker-end:url(#Arrow1Mend)"
       d="M 304,251.36218 C 294.28943,256.41264 292.83565,252.3401 285.05546,253.9809"
       id="path3793"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <text
       sodipodi:linespacing="125%"
       id="text4829"
       y="102.36218"
       x="128.40573"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:end;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:end;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       xml:space="preserve"><tspan
         y="102.36218"
         x="133.39792"
         id="tspan4831"
         sodipodi:role="line">new </tspan><tspan
         id="tspan4833"
         y="124.86218"
         x="128.40573"
         sodipodi:role="line">AR</tspan></text>
    <rect
       style="fill:none;stroke:#000000"
       id="rect4835"
       width="128.06078"
       height="39.641418"
       x="153.85368"
       y="113.2287"
       rx="0"
       ry="0" />
    <rect
       ry="0"
       rx="0"
       y="65.228699"
       x="153.85368"
       height="48.126701"
       width="128.06078"
       id="rect5389"
       style="fill:none;stroke:#000000" />
    <rect
       style="fill:none;stroke:#000000"
       id="rect5391"
       width="128.06078"
       height="98.641411"
       x="153.85368"
       y="-33.771301"
       rx="0"
       ry="0" />
    <text
       sodipodi:linespacing="125%"
       id="text5393"
       y="140.36218"
       x="162.09337"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       xml:space="preserve"><tspan
         y="140.36218"
         x="162.09337"
         id="tspan5395"
         sodipodi:role="line">return address</tspan></text>
    <text
       xml:space="preserve"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       x="176.09337"
       y="82.362183"
       id="text5397"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan5399"
         x="176.09337"
         y="82.362183">control link</tspan><tspan
         sodipodi:role="line"
         x="176.09337"
         y="104.86218"
         id="tspan5401">(saved FP)</tspan></text>
    <text
       sodipodi:linespacing="125%"
       id="text5422"
       y="20.362183"
       x="312"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       xml:space="preserve"><tspan
         y="20.362183"
         x="312"
         id="tspan5424"
         sodipodi:role="line">local variables</tspan></text>
    <g
       transform="translate(156,-289)"
       id="g5426">
      <path
         sodipodi:nodetypes="ccc"
         inkscape:connector-curvature="0"
         id="path5428"
         d="M 131.1234,348.33562 C 151.72064,344.90827 131.79187,317.53097 139.22899,308.04398 144.37567,302.8973 147.33458,304.04398 147.33458,304.04398"
         style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
      <path
         style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
         d="M 131.1234,259.58148 C 151.72064,263.00883 131.79187,290.38613 139.22899,299.87312 144.37567,305.0198 147.33458,303.87312 147.33458,303.87312"
         id="path5430"
         inkscape:connector-curvature="0"
         sodipodi:nodetypes="ccc" />
    </g>
    <path
       sodipodi:nodetypes="ccc"
       inkscape:connector-curvature="0"
       id="path5432"
       d="M 151.83832,-32.41852 C 124.87878,-21.866701 150.96337,62.420091 141.22899,91.62779 134.49255,107.47293 130.61966,103.94263 130.61966,103.94263"
       style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
       d="M 151.83832,246.02806 C 124.87878,235.08239 150.96337,147.64955 141.22899,117.35166 134.49255,100.91509 130.61966,104.57716 130.61966,104.57716"
       id="path5434"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
  </g>
</svg>
		</center>
	</div>
</div>
The parameters will already be on the stack (pushed by calling function).
So the code for function entry must do the following:
<OL class=style1>
  <LI> push the return address
  <LI> push the control link
  <LI> set the FP
  <LI> push space for local variables
</OL>
Here's the code you need to generate:
<pre>
  # (1) push return addr
    sw	 $ra, 0($sp)
    subu $sp, $sp, 4
  # (2) push control link
    sw   $fp, 0($sp)
    subu $sp, $sp, 4
  # (3) set the FP
  # note: the following sets the FP to point to the "bottom"
  #       of the new AR; the reason for "+ 8" is:
  #       4 bytes each for the control link and the return addr
    addu $fp, $sp, &lt;size of params in bytes + 8&gt;
  # (4) push space for locals
    subu $sp, $sp, &lt;size of locals in bytes&gt;
</pre>
Note: <tt>&lt;size of params&gt;</tt> and <tt>&lt;size of locals&gt;</tt>
will need to be available to the code generator.
The symbol-table entry for the function name will have information about
the parameters (because that will have been used for type checking).
For example, it might have a list of the symbol-table entries for
the parameters.
You could also store the total size of the parameters
in the function name's symbol-table entry, or you could write a
method that takes the list of parameters as its argument and computes
the total size.
It is not so easy to compute the total size of the local variables
at code-generation time;
it is probably a better idea to do that during name analysis.
The name-analysis phase will be computing the offsets for the
parameters and local variables anyway;
it should not be difficult to extend that code to also compute the
total size of the locals (and to store that information in the
function name's symbol-table entry).
<P>
<a name="functionBody"></a>
<span class=subsubhead>Function Body</span>
<p>
Note: we are talking about the codeGen method for the FnBodyNode, whose
subtree will look like this:
<div class=row>
	<div class=12u>
		<center>
			<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="295"
   height="122"
   id="svg2"
   version="1.1"
   inkscape:version="0.48.3.1 r9886"
   sodipodi:docname="New document 1">
  <defs
     id="defs4" />
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="1"
     inkscape:cx="225.68165"
     inkscape:cy="47.369019"
     inkscape:document-units="px"
     inkscape:current-layer="layer1"
     showgrid="false"
     fit-margin-top="0"
     fit-margin-left="0"
     fit-margin-right="0"
     fit-margin-bottom="0"
     inkscape:window-width="665"
     inkscape:window-height="724"
     inkscape:window-x="0"
     inkscape:window-y="0"
     inkscape:window-maximized="0" />
  <metadata
     id="metadata7">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(-221.16956,-457.7312)">
    <g
       id="g3013"
       transform="translate(-11.25,0)">
      <rect
         rx="18"
         ry="18"
         y="459.24255"
         x="314.16956"
         height="43.988647"
         width="127.60205"
         id="rect2985"
         style="opacity:0.82999998;fill:none;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0" />
      <text
         sodipodi:linespacing="125%"
         id="text2987"
         y="485.38089"
         x="333.20221"
         style="font-size:16px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
         xml:space="preserve"><tspan
           y="485.38089"
           x="333.20221"
           id="tspan2989"
           sodipodi:role="line">FnBodyNode</tspan></text>
    </g>
    <g
       id="g3008">
      <rect
         style="opacity:0.82999998;fill:none;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0"
         id="rect2991"
         width="127.60205"
         height="43.988647"
         x="384.16956"
         y="535.24255"
         ry="18"
         rx="18" />
      <text
         xml:space="preserve"
         style="font-size:16px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
         x="401.20221"
         y="561.38086"
         id="text2993"
         sodipodi:linespacing="125%"><tspan
           sodipodi:role="line"
           id="tspan2995"
           x="401.20221"
           y="561.38086">StmtListNode</tspan></text>
    </g>
    <g
       id="g3003">
      <rect
         rx="18"
         ry="18"
         y="535.24255"
         x="221.66956"
         height="43.988647"
         width="127.60205"
         id="rect2997"
         style="opacity:0.82999998;fill:none;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0" />
      <text
         sodipodi:linespacing="125%"
         id="text2999"
         y="561.38086"
         x="238.70221"
         style="font-size:16px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
         xml:space="preserve"><tspan
           y="561.38086"
           x="238.70221"
           id="tspan3001"
           sodipodi:role="line">DeclListNode</tspan></text>
    </g>
    <path
       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="M 283.54982,534.76002 332.66861,502.526"
       id="path3018"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       sodipodi:nodetypes="cc"
       inkscape:connector-curvature="0"
       id="path3020"
       d="M 454.66861,534.76002 405.54982,502.526"
       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
  </g>
</svg>
		</center>
	</div>
</div>
<p>
There is no need to generate any code for the declarations.
So to generate code for the function body, just call the codeGen
method of the StmtListNode, which will in turn call the codeGen
method of each statement in the list.
What those methods will do is discussed below in the section on
<A HREF="#stmts">Code Generation for Statements</A>.
<P>
<a name="functionReturn"></a>
<span class=subsubhead>Function Exit</span>
<p>
Just before a function returns, the stack looks like this:
<div class=row>
	<div class=12u>
		<center>
			<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="350"
   height="398"
   id="svg2"
   version="1.1"
   inkscape:version="0.48.3.1 r9886"
   sodipodi:docname="codegen_call2.svg">
  <defs
     id="defs4">
    <marker
       inkscape:stockid="Arrow1Send"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow1Send"
       style="overflow:visible">
      <path
         id="path3814"
         d="M 0,0 5,-5 -12.5,0 5,5 0,0 z"
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt"
         transform="matrix(-0.2,0,0,-0.2,-1.2,0)"
         inkscape:connector-curvature="0" />
    </marker>
    <marker
       inkscape:stockid="Arrow1Mend"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow1Mend"
       style="overflow:visible">
      <path
         id="path3808"
         d="M 0,0 5,-5 -12.5,0 5,5 0,0 z"
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt"
         transform="matrix(-0.4,0,0,-0.4,-4,0)"
         inkscape:connector-curvature="0" />
    </marker>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="0.56445312"
     inkscape:cx="59.602188"
     inkscape:cy="245.0793"
     inkscape:document-units="px"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="665"
     inkscape:window-height="724"
     inkscape:window-x="0"
     inkscape:window-y="1"
     inkscape:window-maximized="0"
     fit-margin-top="0"
     fit-margin-left="0"
     fit-margin-right="0"
     fit-margin-bottom="0" />
  <metadata
     id="metadata7">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(-73.810012,44.629899)">
    <rect
       style="fill:none;stroke:#000000"
       id="rect2985"
       width="128.06078"
       height="98.641411"
       x="153.85368"
       y="252.2287"
       rx="0"
       ry="0" />
    <text
       xml:space="preserve"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:end;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:end;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       x="128.40573"
       y="297.36218"
       id="text3755"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan3757"
         x="133.39792"
         y="297.36218">caller's </tspan><tspan
         sodipodi:role="line"
         x="128.40573"
         y="319.86218"
         id="tspan3759">AR</tspan></text>
    <rect
       ry="0"
       rx="0"
       y="154.2287"
       x="153.85368"
       height="98.641411"
       width="128.06078"
       id="rect3761"
       style="fill:none;stroke:#000000" />
    <text
       xml:space="preserve"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       x="312"
       y="202.36218"
       id="text3763"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan3765"
         x="312"
         y="202.36218">parameters</tspan></text>
    <text
       xml:space="preserve"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       x="305"
       y="257.36218"
       id="text3767"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan3769"
         x="305"
         y="257.36218">FP</tspan></text>
    <text
       sodipodi:linespacing="125%"
       id="text3771"
       y="-29.561699"
       x="309"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;opacity:0.82999998;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       xml:space="preserve"><tspan
         y="-29.561699"
         x="309"
         id="tspan3773"
         sodipodi:role="line">SP</tspan></text>
    <path
       style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
       d="M 149.33458,257.58148 C 128.73734,261.00883 148.66611,288.38613 141.22899,297.87312 136.08231,303.0198 133.1234,301.87312 133.1234,301.87312"
       id="path3775"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       sodipodi:nodetypes="ccc"
       inkscape:connector-curvature="0"
       id="path3781"
       d="M 149.33458,346.33562 C 128.73734,342.90827 148.66611,315.53097 141.22899,306.04398 136.08231,300.8973 133.1234,302.04398 133.1234,302.04398"
       style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
    <g
       id="g3787"
       transform="translate(156,-101)">
      <path
         style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
         d="M 131.1234,348.33562 C 151.72064,344.90827 131.79187,317.53097 139.22899,308.04398 144.37567,302.8973 147.33458,304.04398 147.33458,304.04398"
         id="path3783"
         inkscape:connector-curvature="0"
         sodipodi:nodetypes="ccc" />
      <path
         sodipodi:nodetypes="ccc"
         inkscape:connector-curvature="0"
         id="path3785"
         d="M 131.1234,259.58148 C 151.72064,263.00883 131.79187,290.38613 139.22899,299.87312 144.37567,305.0198 147.33458,303.87312 147.33458,303.87312"
         style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
    </g>
    <path
       style="opacity:0.82999998;fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;marker-end:url(#Arrow1Mend)"
       d="M 307,-35.561702 C 296.06116,-29.591622 298.64887,-37.232002 284,-34.686702"
       id="path3791"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;marker-end:url(#Arrow1Mend)"
       d="M 304,251.36218 C 294.28943,256.41264 292.83565,252.3401 285.05546,253.9809"
       id="path3793"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <text
       sodipodi:linespacing="125%"
       id="text4829"
       y="102.36218"
       x="128.40573"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:end;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:end;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       xml:space="preserve"><tspan
         y="102.36218"
         x="133.39792"
         id="tspan4831"
         sodipodi:role="line">new </tspan><tspan
         id="tspan4833"
         y="124.86218"
         x="128.40573"
         sodipodi:role="line">AR</tspan></text>
    <rect
       style="fill:none;stroke:#000000"
       id="rect4835"
       width="128.06078"
       height="39.641418"
       x="153.85368"
       y="113.2287"
       rx="0"
       ry="0" />
    <rect
       ry="0"
       rx="0"
       y="65.228699"
       x="153.85368"
       height="48.126701"
       width="128.06078"
       id="rect5389"
       style="fill:none;stroke:#000000" />
    <rect
       style="fill:none;stroke:#000000"
       id="rect5391"
       width="128.06078"
       height="98.641411"
       x="153.85368"
       y="-33.771301"
       rx="0"
       ry="0" />
    <text
       sodipodi:linespacing="125%"
       id="text5393"
       y="140.36218"
       x="162.09337"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       xml:space="preserve"><tspan
         y="140.36218"
         x="162.09337"
         id="tspan5395"
         sodipodi:role="line">return address</tspan></text>
    <text
       xml:space="preserve"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       x="176.09337"
       y="82.362183"
       id="text5397"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan5399"
         x="176.09337"
         y="82.362183">control link</tspan><tspan
         sodipodi:role="line"
         x="176.09337"
         y="104.86218"
         id="tspan5401">(saved FP)</tspan></text>
    <text
       sodipodi:linespacing="125%"
       id="text5422"
       y="20.362183"
       x="312"
       style="font-size:18px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Charter;-inkscape-font-specification:Bitstream Charter"
       xml:space="preserve"><tspan
         y="20.362183"
         x="312"
         id="tspan5424"
         sodipodi:role="line">local variables</tspan></text>
    <g
       transform="translate(156,-289)"
       id="g5426">
      <path
         sodipodi:nodetypes="ccc"
         inkscape:connector-curvature="0"
         id="path5428"
         d="M 131.1234,348.33562 C 151.72064,344.90827 131.79187,317.53097 139.22899,308.04398 144.37567,302.8973 147.33458,304.04398 147.33458,304.04398"
         style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
      <path
         style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
         d="M 131.1234,259.58148 C 151.72064,263.00883 131.79187,290.38613 139.22899,299.87312 144.37567,305.0198 147.33458,303.87312 147.33458,303.87312"
         id="path5430"
         inkscape:connector-curvature="0"
         sodipodi:nodetypes="ccc" />
    </g>
    <path
       sodipodi:nodetypes="ccc"
       inkscape:connector-curvature="0"
       id="path5432"
       d="M 151.83832,-32.41852 C 124.87878,-21.866701 150.96337,62.420091 141.22899,91.62779 134.49255,107.47293 130.61966,103.94263 130.61966,103.94263"
       style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
    <path
       style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
       d="M 151.83832,246.02806 C 124.87878,235.08239 150.96337,147.64955 141.22899,117.35166 134.49255,100.91509 130.61966,104.57716 130.61966,104.57716"
       id="path5434"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
  </g>
</svg>
		</center>
	</div>
</div>
We need to generate code to pop off this function's AR, then to jump to the
address in the "return address" field.
Popping off the AR means restoring the SP and FP.
Note that we want to move the SP to where the FP is currently
pointing, but if there may be an interrupt that could use the stack,
we don't want to change the SP until we're finished with all of
the values in the current AR (in particular, the control link,
which is used to restore the FP).
Therefore, we use a temporary register (t0) to save the address
that is initially in the FP
<P>
Here is the code that needs to be generated:
<pre>
  lw   $ra, -&lt;param size&gt;($fp)    # load return address
  move $t0, $fp                   # save control link
  lw   $fp, -&lt;paramsize+4&gt;($fp)   # restore FP
  move $sp, $t0                   # restore SP
  jr   $ra                        # return
</pre>
Note that there are two things that cause a function to return:
<OL>
  <LI> A <tt>return</tt> statement is executed, or
  <LI> The last statement in the function is executed (i.e., execution
       "falls off the end" of the function).
</OL>
You could generate the "return" code given above for each <tt>return</tt>
statement as well as after the last statement in the function body.
A more space-efficient approach would be:
<UL>
  <LI> Generate the "return" code just once after generating the code
       for the function body.
       Label that code with a unique label (e.g., the result of
       calling <a href="#aux">nextLabel</a>).
  <LI> For each <tt>return</tt> statement, generate a jump to the
       label you used (the op code for an unconditional jump is
       just <tt>b</tt>).
</UL>
<P>
<a name="returnV0"></a>
What about a return statement that returns a value?
As discussed below, the codeGen method for the returned
expression will generate code to evaluate that expression,
leaving the value on the stack.
The MIPS convention is to use register V0 to return a int value
from a function and to use register F0 to return a double value.
So the codeGen method for the return statement should generate
code to pop the value from the stack into the appropriate register
(before generating the "return" code or the jump to the return code
discussed above).
<P>
<a name=stmts></a>
<span class=subhead>Code Generation for Statements</span>
<P>
You will write a different codeGen method for each kind of StmtNode.
You are strongly advised to write this method for the WriteIntStmtNode,
WriteDblStmtNode,
and WriteStrStmtNode first.
Then you can test code generation for the other kinds of
statements and the expressions by writing a program that computes
and prints a value.
It will be much easier to find errors in your code this way (by
looking at the output produced when a program is run) than by
looking at the assembly code you generate.
<P>
<a name="printstmt"></a>
<span class=subsubhead>Write Statement</span>
<p>
To generate code for a write statement whose expression is of type
<em>int</em> you must:
<OL>
  <LI> Call the codeGen method of the expression being printed.
       That method will generate code to evaluate the expression,
       leaving that value on the top of the stack.
  <LI> Generate code to pop the top-of-stack value into register A0
       (a special register used for output of strings and ints)
  <LI> Generate code to set register V0 to 1.
  <LI> Generate a <tt>syscall</tt> instruction.
</OL>
<P>
Below is the code <em>you</em> would write for the codeGen method of
the WriteIntStmtNode.
<pre>
    // step (1)
    myExp.codeGen();
    
    // step (2)
    genPop(A0, 4);
    
    // step (3)
    generate("li", V0, 1);
    
    // step (4)
    generate("syscall");
</pre>
The code for the WriteStrStmtNode and the WriteDblStmtNode
is similar, except for the following:
<UL>
  <LI> For a string, the codeGen method of the expression being
       printed will leave the address of the string on the stack.
  <LI> For a double, the value to be written must be popped
       into register F12 instead of A0.
  <LI> For a string, register V0 must be set to 4.
  <LI> For a double, register V0 must be set to 3.
</UL>

<P>
<a name="if"></a>
<span class=subhead>If-Then Statement</span>
The AST for an if-then statement looks like:
<pre>
                    ------------
                   | IfStmtNode |
                    ------------
                 /       |        \
       ---------   --------------   -------------
      | ExpNode | | DeclListNode | | StmtListNode|
       ---------   --------------   -------------
</pre>
There are two different approaches to generating code for statements
that involve conditions (e.g., for if statements and while loops):
<OL>
  <LI> The <em>numeric</em> method, and
  <LI> the <em>control-flow</em> method.
</OL>
We will discuss code generation for if-then statements assuming the
numeric method here;
the control-flow method will be discussed later.

The code generated by the IfStmtNode's codeGen method will have the
following form:
<OL>
  <LI> Evaluate the condition, leaving the value on the stack.
  <LI> Pop the top-of-stack value into register T0.
  <LI> Jump to FalseLabel if T0 == FALSE.
  <LI> Code for the statement list.
  <LI> FalseLabel:
</OL>
<P>
<a name="labels"></a>
<span class=subsubhead>Labels</span>
<P>
Note that the code generated for an if-then statement will need to include
a label.
Each label in the generated code must have a unique name (although we
will refer to labels in these notes using names like "FalseLabel" as above).
As discussed <a href="#aux">above</a>, we will assume that there is a method
called <em>nextLabel</em>
that returns (as a String) a new label every time it is called, and
we will assume that there is a method called <em>genLabel</em> that
prints the given label to the assembly-code file.
<P>
<hr>
<a name=youtry1>
<P>
<center>
<u><b>TEST YOURSELF #1</b></u>
</center></a>
<P>
<b>Question 1:</b>
What is the form of the code generated by an IfElseStmtNode's
codeGen method?
<P>
<b>Question 2:</b>
What is the actual code that needs to be written for the
IfStmtNode's codeGen method?
<P>
<b>Question 3:</b>
What is the form of the code generated by a WhileStmtNode's codeGen method?
<p><a href="SOLUTIONS/CODE-GEN-ANSWERS.html">solution</a></p>

<hr>
<P>
<a name="return"></a>
<span class=subsubhead>Return Statement</span>
<p>
The AST for a return statement is either:
<pre>
                    ----------------
                   | ReturnStmtNode |
                    ----------------
</pre>
or:
<pre>
                    ----------------
                   | ReturnStmtNode |
                    ----------------
                           |
                      -----------
                      | ExpNode |
                      -----------
</pre>
As discussed <a href="#returnV0">above</a>,
if a value is being returned, the ReturnStmtNode's
codeGen method should call its ExpNode's codeGen method (to generate
code to evaluate the returned expression, leaving the value on the
stack), then should generate code to pop that value into register V0
or register F0 (depending on its type).
<P>
To generate the code that actually does the return, use one of
the following approaches:
<OL>
  <LI> For each return statement in the program, generate a copy of
       the code that pops the AR off the stack then jumps to the
       return address (that code was discussed above under
       <A HREF="#functionReturn">Function Exit</A>), or
  <LI> For each return statement in the program, generate a jump to
       the "return" code that is generated at the end of the function.
       Note that in this case you will need to label that return code,
       and you will need to know what that label is when generating code
       for a return statement.
</OL>

<P>
<a name="read"></a>
<span class=subsubhead>Read Statement</span>
<p>
The AST for a read statement is one of the following:
<pre>
            -------------------                 -------------------
            | ReadIntStmtNode |                 | ReadDblStmtNode |
            -------------------                 -------------------
                   |                                     |
              ----------                           ----------
              | IdNode |                           | IdNode |
              ----------                           ----------
</pre>
<P>
To read an integer value into register V0, you must generate this code:
<UL>
<pre>
    li    $v0,  5
syscall
</pre>
</UL>
The code loads the special value 5 into register V0, then does a
syscall.
The fact that V0 contains the value 5 tells the syscall to read
an integer value from standard input, storing the value back
into register V0.
So we must start by generating the above code, then we must
generate code to store the value from V0 to the address of
the IdNode.
<P>
To read a double value, load the value 7 into V0, do
a syscall, and expect the input value to be in register F0 (not V0).
</UL>
<P>
<a name="names"></a>
<span class=subsubhead>Digression: Code Generation for IdNodes</span>
<p>
Before considering other kinds of statements, let's think about the role
identifiers will play in code generation.
Names show up in the following contexts:
<UL>
  <LI> function calls (the name of the called function)
  <LI> expressions (an expression can be just a name, or a name can be the
       operand of any operator)
  <LI> assignment statements (on the left-hand side)
</UL>
The code that needs to be generated for the name will be different
in each context:
<OL>
  <LI> For a function call, we will need to generate a jump-and-link
       instruction using the name of the function (the same name that
       was generated as a label in the function's "preamble" code).
  <LI> For an expression, we will need to generate code to fetch the
       current value either from the static data area or from the
       current Activation Record, and to push that value onto the stack.
  <LI> For an assignment, we will need to generate code to push the
       <em>address</em> of the variable (either the address in the
       static data area, or in the current Activation Record) onto the
       stack.  Then we will generate code to store the value of the
       right-hand-side expression into that address.
</OL>
Therefore, it seems reasonable to write three different code-generation
methods for the IdNode class;
for example:
<UL>
  <LI> genJumpAndLink,
  <LI> codeGen,
  <LI> genAddr.
</UL>
<P>
We use "codeGen" for the second case (fetching the value and pushing
it onto the stack) since that is what the codeGen methods of all
ExpNodes must do.
<P>
<a name="jal"></a>
<H3>genJumpAndLink</H3>
The genJumpAndLink method will simply generate a jump-and-link
instruction (with opcode <tt>jal</tt>) using the appropriate
label as the target of the jump.
If the called function is "main", the label is just "main".
For all other functions, the label is of the form:
<UL>
_&lt;functionName&gt;
</UL>
<P>
<a name="codeGen"></a>
<H3>codeGen</H3>
The codeGen method must copy the value of the global / local variable
into a register (e.g., T0 for an int variable and F0 for a double),
then push the value onto the stack.
Different code will be generated for a global and a local variable.
Below are four examples.
<TABLE align=center>
<tr><td><tt>lw $t0 _g</tt> 
    <td><tt>// load the value of int global <em>g</em> into T0</tt>
<tr><td><tt>lw $t0 0($fp)</tt> 
    <td><tt>// load the value of the int local stored at offset 0 into T0</tt>
<tr><td><tt>l.d $f0 _d</tt> 
    <td><tt>// load the value of dbl global <em>d</em> into F0</tt>
<tr><td><tt>l.d $f0 -4($fp)</tt> 
    <td><tt>// load the value of the dbl local stored at offset -4 into F0</tt>
</TABLE>
<P>
Note that this means there must be a way to tell whether an IdNode
represents a global or a local variable.
There are several possible ways to accomplish this:
<UL>
  <LI> The symbol-table entry includes a "kind" field (which distinguishes
       between globals and locals).
  <LI> Different sub-classes of the Sym class are used for globals and
       for local variables (so you can tell whether you have a global or
       a local using "instanceof", or using an IsGlobal method that you
       write for each sub-class of Sym).
  <LI> The symbol-table entry includes an "offset" field; for local variables,
       that field has a value less than or equal to zero, while for
       globals, the value is greater than zero.
</UL>
<P>
<a name="genAddr"></a>
<H3>genAddr</H3>
The genAddr method must load the address of the identifier into a register
(e.g., T0), then push it onto the stack.
The code is very similar to the code to load the <em>value</em> of the
identifier; we just use the <em>la</em> (load address) opcode instead
of the <em>lw</em> (load word) or <em>l.d</em> (load double) opcode.
<P>
Here is the code you need to generate to load the address of a global
variable <em>g</em> into register T0 (this works whether <tt>g</tt>
is int or double, since an address always takes 4 bytes):
<UL>
<tt>la $t0, _g</tt>
</UL>
and here is the code for a local, stored at offset -8:
<UL>
<tt>la $t0, -8($fp)</tt>
</UL>

<a name="assign"></a>
<H2>Assignment Statement</H2>
The AST for an assignment statement looks like this:
<pre>
		 ----------------
		| AssignStmtNode |
		 ----------------
		         |
		    ------------
	 	   | AssignNode |
		    ------------
		 /               \
           --------          ---------
          | IdNode |        | ExpNode |
           --------          ---------	
</pre>
The AssignStmtNode's codeGen method can call the AssignNode's
method to do the assignment, but be careful:
an AssignNode is a subclass of ExpNode, so like all nodes that
represent expressions, it must leave the value of the expression
on the stack.
Therefore, the AssignStmtNode must generate code to pop (and
ignore) that value.

<P>
<a name=exps></a>
<span class=subhead>Code Generation for Expressions</span>
<P>
The codeGen method for the subclasses of ExpNode must all generate
code that evaluates the expression and leaves the value on top
of the stack.
We have already talked about how to do this for
IdNodes;
in the subsections below we discuss code generation for other
kinds of expressions.

<P>
<a name=assignExp></a>
<span class=subsubhead>Assign</span>
<P>
<P>
The codeGen method for an assignment expression must generate code to:
<OL>
  <LI> Evaluate the right-hand-side expression, leaving the value
       on the stack.
  <LI> Push the address of the left-hand-side Id onto the stack.
  <LI> Store the value into the address.
  <LI> Leave a copy of the value on the stack.
</OL>
Most of the work is done by calling the
AssignNode's children's methods:
the codeGen method of the right-hand-side ExpNode,
and the genAddr method of the left-hand-side IdNode.
How to accomplish the rest of the assignment is left to you
to figure out (it isn't too difficult).

<P>
<a name=literals></a>
<span class=subsubhead>Literals</span>
<P>
The codeGen methods for IntLitNodes
must simply generate code to push the literal value onto the stack.
The generated code will look like this:
<pre>
           li    $t0, &lt;value&gt;        # load value into T0
           sw    $t0, ($sp)          # push onto stack
           subu  $sp, $sp, 4
</pre>
<P>
The code for a DblLitNode is similar, except that
the value must be loaded into a double register using the
appropriate opcode, and the "push" code is different for
a double value.
For example:
<pre>
           li.d  $f0, &lt;value&gt;    # load value into F0
           s.d   $f0, -4($sp)    # push onto stack
           subu  $sp, $sp, 8
</pre>
<P>
For a StringLitNode, the string literal itself must be stored in the
static data area, and its <em>address</em> must be pushed.
The code to store a string literal in the static data area looks like this:
<pre>
           .data
  &lt;label&gt;: .asciiz &lt;string value&gt;
</pre>
Note:
<OL>
  <LI> &lt;label&gt; needs to be a <em>new</em> label; e.g., returned by
       a call to nextLabel.
  <LI> The &lt;string value&gt; needs to be a string in
       quotes.  You should be storing string literals
       that way, so just write out the value of the
       string literal, quotes and all.
</OL>
To avoid storing the same string literal value more than once, keep
a hashtable in which the keys are the string literals, and the
associated information is the static-data-area label.
When you process a string literal, look it up in the hashtable:
if it is there, use its associated label;
otherwise, generate code to store it in the static data area,
and add it to the hashtable.
<P>
The code you need to generate to push the address of a string literal
onto the stack looks like this:
<pre>
           .text
           la   $t0, &lt;label&gt;       # load addr into $t0
           sw   $t0, ($sp)         # push onto stack
           subu $sp, $sp, 4
</pre>
<P>
<a name="call"></a>
<span class=subsubhead>Function Call</span>
<p>
The AST for a function call looks like:
<pre>
		 --------------
		| CallExpNode |
		 --------------
		 /             \
            --------         -------------
           | IdNode |       | ExpListNode |
            --------         -------------
</pre>
We need to generate code to:
<OL>
  <LI> Evaluate each actual parameter, pushing the values onto the stack;
  <LI> Jump and link (jump to the called function, leaving the return
       address in the RA register).
  <LI> Push the returned value (which will be in register V0 or F0
       depending on the return type) onto the stack.
</OL>
Since the codeGen method for an expression generates code to evaluate the
expression, leaving the value on the stack, all we need to do for step 1
is call the codeGen method of the ExpListNode (which will in turn call
the codeGen methods of each ExpNode in the list).
For step 2, we just call the genJumpAndLink method of the IdNode.
For step 3, we just call genPush(V0, 4) or genPush(F0, 8).
<P>
Note that there is also a call <em>statement</em>:
<pre>
		 --------------
		| CallStmtNode |
		 --------------
                       |
		 --------------
		| CallExpNode |
		 --------------
		 /             \
            --------         -------------
           | IdNode |       | ExpListNode |
            --------         -------------
</pre>
In this case, the called function may not actually return a value
(i.e., may have return type <em>void</em>).
It doesn't hurt to have the CallExpNode's codeGen method push the
value in V0 (or F0) after the call (it will just be pushing some
random garbage), but it <em>is</em> important for the CallStmtNode's
codeGen method to pop that value.
<P>
<a name=arith></a>
<span class=subsubhead>Non Short-Circuited Operators</span>
<P>
In general, the codeGen methods for the non short-circuited operators
(PlusNode, MinusNode, ..., NotNode, LessNode, ..., EqualsNode, etc.)
must all do the same basic sequence of tasks:
<OL>
  <LI> Call each child's codeGen method to generate code that will
       evaluate the operand(s), leaving the value(s) on the stack.
  <LI> Generate code to pop the operand value(s) off the stack into
       register(s) (e.g., T0 and T1 for ints; F0 and F2 for doubles).
       Remember that if there are two operands, the <em>right</em> one will
       be on the top of the stack.
  <LI> Generate code to perform the operation (see Spim documentation for a
       list of opcodes).
  <LI> Generate code to push the result onto the stack.
</OL>
The relational and equality operators are more complicated if they
are applied to double operands (because there are no opcodes that
"directly" compute the desired result).
However, implementing those cases is not required for the class
project (unless you want extra credit), so we will not discuss the
details here.
<P>
To minimize the amount of code you must write, you might want
to define subclasses of ExpNode that have very similar
code-generation methods.
For example, you could define a BinaryExpNode class whose codeGen
method does all of the steps above, calling an opCode method
(that would be implemented in each BinaryExpNode subclass) to
get the appropriate opcode for use in step 3.
<P>
Note that the comparison operators (described in Section 2.6 of the
Spim Reference Manual) produce one when the result of
the comparison is true.
However, the not operator does a bitwise logical negation, so it will
not work correctly if you use 0 and 1 to represent true and false.
Thus, it is better to use the seq operator instead of the not operator.
<P>
<b>Example:</b>
Recall that the AST for an addition looks like this:
<pre>
		 ----------
		| PlusNode |
		 ----------
		 /        \
          ---------      ---------
         | ExpNode |    | ExpNode |
          ---------      ---------
</pre>
Here is the codeGen method for the PlusNode, assuming
that both operands are ints.
<UL>
<pre>
public void codeGen() {
    // step 1: evaluate both operands
    myExp1.codeGen();
    myExp2.codeGen();

    // step 2: pop values in T0 and T1
    genPop(T1, 4);
    genPop(T0, 4);
    
    // step 3: do the addition (T0 = T0 + T1)
    generate("add", T0, T0, T1);
    
    // step 4: push result
    genPush(T0, 4)
}
</pre>
</UL>
<P>
To illustrate how code is generated for an expression involving
several operators,
consider generating code for the expression: <tt>b + c * d</tt>.
Here is the AST for the expression:
<pre>
                PlusNode
                /       \
	     IdNode   TimesNode
               b       /     \
                     IdNode  IdNode
                        c      d

</pre>
Below is the sequence of calls that would be
made at compile time to generate code for this expression, and a
description of what the generated code does.
<pre>
        Sequence of calls          What the generated code does
	-----------------	   ----------------------------

  +--- PlusNode.codeGen()
  |      IdNode.codeGen()  --------->       push b's value
  | +-   TimesNode.codeGen()
  | |      IdNode.codeGen() --------->      push c's value
  | |      IdNode.codeGen() --------->      push d's value
  | |
  | +------------------------------->   pop d's value into T1
  |                                     pop c's value into T0
  |                                     T0 = T0 * T1
  |                                     push T0's value
  |
  +---------------------------------> pop result of * into T1
                                      pop b's value into T0
                                      T0 = T0 + T1
                                      push T0's value
</pre>

<P>
<a name=logic></a>
<span class=subsubhead>Short-Circuited Operators</span>
<P>
The short-circuited operators are represented by AndNodes and OrNodes.
"Short-circuiting" means that the right operand is evaluated only if necessary.
For example, for the expression <tt>(j != 0) && (k/j > epsilon)</tt>,
the sub-expression <tt> (k/j > epsilon)</tt> is evaluated only if
variable <tt>j</tt> is not zero.
Therefore, the code generated for an AndNode must work as follows:
<pre>
  evaluate the left operand
  if the value is true then
     evaluate the right operand;
     that value is the value of the whole expression
  else
     don't bother to evaluate the right operand
     the value of the whole expression is false
</pre>
Similarly, for an OrNode:
<pre>
  evaluate the left operand
  if the value is false then
     evaluate the right operand;
     that value is the value of the whole expression
  else
    don't bother to evaluate the right operand
    the value of the whole expression is true
</pre>
This means that the code generated for the logical operators will need to
involve some jumps depending on the values of some expressions.
<P>
<hr>
<a name=youtry2>
<P>
<center>
<u><b>TEST YOURSELF #2</b></u>
</center></a>
<P>
Expand the outlines given above for the code generated for AndNodes
and OrNodes, giving a lower-level picture of the generated code.
Use the outline of the code generated for an <a href="#if">if-then</a>
statement as a model of what to write.

<p><a href="SOLUTIONS/CODE-GEN-ANSWERS.html">solution</a></p>
<hr>
<P>
<a name=jumpcode></a>
<span class=subhead>Control-Flow Code</span>
<P>
As mentioned above in the section on <A HREF="#if">If-Then Statements</A>,
there are actually two different approaches to generating code for
statements with conditions (like if statements and while loops):
<OL>
  <LI> The <em>numeric</em> approach: This is the approach that we have
       assumed so far.  Using the numeric approach, the codeGen
       method for a statement with a condition generates code to
       evaluate the condition, leaving the value on the stack.
       That value is then popped, and a jump is executed if it
       has a particular value.
  <LI> The <em>control-flow</em> or <em>jump-code</em> approach:
       In this case, the code-generation method for the condition
       has two parameters, both of which are labels (i.e.,
       Strings) named TrueLabel and FalseLabel.
       Instead of leaving the value of the condition
       on the stack, the code generated to evaluate the condition
       jumps to the TrueLabel if the condition is <em>true</em>, and
       jumps to the FalseLabel if the condition is <em>false</em>.
</OL>
We will assume that the new code-generation method for the condition
is called genJumpCode.
As we will see, the reason to prefer the control-flow approach over
the numeric approach is that, using the control-flow approach, we will
generate fewer instructions for statements that involve conditions (so
the generated code will be smaller and will run faster).
<P>
First, let's reconsider code generation for an if-then statement;
this time we'll use the control-flow method instead of the
numeric method for evaluating the condition part of the statement.
Under this new assumption, the code generated by the IfStmtNode's
codeGen method will have the following form:
<pre>
           -- code to evaluate the condition, jumping to TrueLab if it is <em>true</em>,
	      and to DoneLab if it is <em>false</em> --
  TrueLab:
           -- code for the statement list --
  DoneLab:
</pre>
The actual code written for the IfStmtNode's codeGen method will be:
<UL>
<pre>
public void codeGen() {
   String trueLab = nextLabel();
   String doneLab = nextLabel();
   myExp.genJumpCode(trueLab, doneLab);
   genLabel(trueLab);
   myStmtList.codeGen();
   genLabel(doneLab);
}
</pre>
</UL>
<P>
To implement the control-flow approach, in addition to changing
the codeGen method for the statements that have conditions,
we must also write a new genJumpCode method
for each AST node that could represent a condition.
Below, we look at two representative cases, for
IdNode and LessNode.
We give the code generated for the (old) numeric approach, and
for the (new) control-flow approach so that we can see which
code is better (in terms of the number of instructions).
(The code given below assumes that all operands are int, and it
is not quite assembly code -- for example, for
clarity, we use "push" instead of the actual two instructions that
implement a push operation.)
<pre>
  IdNode:  numeric                            control-flow
           -------                            ------------

            lw  $t0, &lt;var's addr&gt;             lw  $t0, &lt;var's addr&gt;
            push $t0                          beq $t0, FALSE, falseLab
                                              b   trueLab
</pre>
Note that in both approaches to generating code for an IdNode,
3 instructions are generated (because "push" is actually 2 instructions).
However, while all 3 of the numeric-approach instructions will always
execute, the last instruction generated by the control-flow approach
will execute only if the value of the Id is <em>true</em>.
<pre>
  LessNode:  numeric                                     control-flow
             -------                                     ------------

             -- code to evaluate both operands           -- ditto
             -- pop values into T1, T0                   -- ditto
             slt  $t2, $t0, $t1                          blt $t0, $t1, trueLab
             push $t2                                    b   falseLab
</pre>
The operands of a LessNode are integer expressions, not boolean expressions,
so both approaches start by generating (the same) code
to evaluate the operands and to pop their values into registers T0 and T1.
After that, however, the numeric approach will generate 3 instructions
(to set $t2 to TRUE or FALSE as appropriate, then to push that value
onto the stack -- remember that "push" is really two instructions),
while the control-flow code will generate only 2 instructions.
Furthermore, as was the case for the IdNode, all three of the numeric-approach
instructions will always execute, while the last instruction generated by the
control-flow approach will only execute if the comparison evaluates to
FALSE.
<P>
Now let's consider how to write the new genJumpCode method
for the short-circuited operators (AndNodes and OrNodes).
<P>
Recall that the AST for an && expression looks like this:
<pre>
		 ---------
		| AndNode |
		 ---------
		 /        \
           ---------       ---------
          | ExpNode |     | ExpNode |
           ---------       ---------	
</pre>
Here's how the genJumpCode method of the AndNode works:
<UL>
  <LI> Start by calling the genJumpCode method of the left child.
       That call will generate code to evaluate the left operand,
       jumping to the "TrueLabel" that we pass if its value is true,
       and jumping to the "FalseLabel" that we pass if its value is false.
  <LI> So what labels should be passed?
       <UL>
         <LI> If the left operand is false, then the value of the whole
	      expression is false, so
              pass the given "FalseLabel" as the "FalseLabel" in the
              recursive call.
         <LI> If the left operand is true, then we must evaluate the right
  	      operand, so pass a <em>new</em> label as the
	      "TrueLabel" in the recursive call.
       </UL>
  <LI> After the call to the left child's genJumpCode method,
       call genLabel to generate the new label.
  <LI> Finally, call the genJumpCode method of the right child.
  <LI> What labels should be passed as the arguments to the right child's
       genJumpCode method?
       <UL>
         <LI> This expression will only be evaluated if the left
	      operand evaluated to true; in that case, the value of this
	      expression (the right operand) is the value of the
	      <em>whole</em> expression.
	      Therefore, for this recursive call, pass
      	      the original "TrueLabel" and "FalseLabel".
        </UL>
</UL>
<P>
The AndNode's genJumpCode method would be:
<UL>
<pre>
public void genJumpCode(String trueLab, String falseLab) {
    String newLab = nextLabel();
    
    myExp1.genJumpCode(newLab, falseLab);
    genLabel(newLab);
    myExp2;genJumpCode(trueLab, falseLab);
}
</pre>
</UL>

<b>Example:</b>
Consider the code that would be generated for the statement:
<tt>if (a && b>0) { ... }</tt>, represented by the AST:
<UL>
<pre>
                    ------------
                   | IfStmtNode |
                    ------------
                 /       |        \
       ---------   --------------   -------------
      | AndNode | | DeclListNode | | StmtListNode|
       ---------   --------------   -------------
       /        \
  --------       ----------
 | IdNode |     | LessNode |
  --------       ----------    
                /          \
              ...         ...
</pre>
</UL>
The IfStmtNode's codeGen method would create two labels, TrueLab and
DoneLab, and would call the AndNode's genJumpCode method,
passing those labels as the arguments.
The AndNode's genJumpCode method would create one new label (NewLab)
and then would call the genJumpCode
method of its left child (the IdNode), passing NewLab and DoneLab as
the arguments.
It would then generate the NewLab label, and then would call
its right child's genJumpCode method, passing TrueLab and DoneLab.
The code generated for the whole condition would look like this:
<UL>
<pre>
         Generated Code                                  Generated By
	 --------------					 ------------

            -- code to load the value of a into T0          IdNode
            jump to DoneLab if T0 == FALSE                  IdNode
            jump to NewLab                                  IdNode
NewLab:                                                     AndNode
            -- code to push the value of b                  LessNode's child
            -- code to push the iteral 0                    LessNode's child
            pop into T1                                     LessNode
            pop into T0                                     LessNode
            jump to TrueLab if T0 < T1                      LessNode
            jump to DoneLab                                 LessNode
</pre>
</UL>
(Of course, the actual label would be something like <tt>L3</tt>, not
<tt>NewLab</tt>.)
After calling the AndNode's genJumpCode method, the IfStmtNode's
codeGen method would call genLabel to print TrueLab, then would call
its StmtList child's codeGen method to generate code for the
list of statements.
Finally, it would call genLabel to print DoneLab.
So the code generated for this if statement would be like this:
<UL>
<pre>
            -- code to load the value of a into T0
            jump to DoneLab if T0 == FALSE
            jump to NewLab
NewLab:
            -- code to push the value of b
            -- code to push the iteral 0
            pop into T1
            pop into T0
            jump to TrueLab if T0 < T1
            jump to DoneLab
TrueLab:
	    -- code for the list of statements
DoneLab:
</pre>
</UL>
<hr>
<a name=youtry3>
<P>
<center>
<u><b>TEST YOURSELF #3</b></u>
</center></a>
<P>
<b>Question 1</b>:
What is the form of the code generated by an OrNode's
genJumpCode method?
<P>
<b>Question 2</b>:
What is the form of the code generated by a NotNode's
genJumpCode method?

<p><a href="SOLUTIONS/CODE-GEN-ANSWERS.html">solution</a></p>
<hr>
<P>
How does the code generated for an AndNode using the control-flow
method compare to the code generated using the numeric method?
Here are outlines of the code generated in each case:
<UL>
<pre>
   Numeric Code                                  Control-Flow Code
   ------------                                  -----------------

   -- code to evaluate left                         -- code to evaluate left
   -- operand, leaving the                          -- operand, including jumps
   -- value on the stack                            -- to NewLab and FalseLab
   <b>pop into T0</b>                                  
   <b>goto TrueLab if T0 == TRUE</b>                 newLab:
   <b>push FALSE</b>
   <b>goto DoneLab</b>
TrueLab:
   -- code to evaluate right                        -- code to evaluate right
   -- operand, leaving the                          -- operand, including
   -- value on the stack                            -- jumps to TrueLab and
                                                    -- FalseLab
DoneLab:
</pre>
</UL>
Note that the numeric code includes 6 instructions (shown in bold)
in addition to the ones
generated by the codeGen methods of the two children, while
in the control-flow case, <em>no</em> instructions are generated by the
AndNode itself (just a label);
the instructions are all generated by the genJumpCode methods of
its two children.
Those children could represent names, boolean literals, comparisons
or logical expressions.
We have already seen that in the first three cases, better code is
generated using the control-flow approach.
Now we see that for logical expressions (at least for AndNodes)
fewer instructions are generated using the control-flow approach
than using the numeric approach.
<hr>
<a name=youtry4>
<P>
<center>
<u><b>TEST YOURSELF #4</b></u>
</center></a>
<P>
Compare the code generated by the two approaches
for an OrNode and for a NotNode.

<p><a href="SOLUTIONS/CODE-GEN-ANSWERS.html">solution</a></p>
<hr>
<P>
Finally, let's compare the code generated by the numeric and control-flow
approaches for an if-then statement.
Here are outlines of the two different versions of the code that would
be generated:
<UL>
<pre>
   Numeric Code                                  Control-Flow Code
   ------------                                  -----------------

   -- code for condition, leaving                -- code for condition,
   -- value on the stack                         -- including jumps to
                                                 -- trueLab and falseLab
   pop into T0
   goto falseLab if T0 == FALSE               trueLab: 
   -- code for "then" stmts                      -- code for "then" stmts
   goto doneLab                                  goto doneLab
falseLab:                                     falseLab:          
   -- code for "else" stmts                      -- code for "else" stmts
doneLab:                                      doneLab:
</pre>
</UL>
Note that much of the code is the same for the two methods;
the code generated to evaluate the condition will be different, and
the numeric method has three extra instructions: a pop, followed
by a conditional goto (those instructions are shown in bold font).
So as long as the code generated for the condition is no worse for the
control-flow method than for the numeric method, the control-flow
method is better (both in terms of the number of instructions generated,
and in terms of the number of instructions that will be executed).
<P>
But we have already looked at the code generated
for all the different kinds of conditions, for each of the two
approaches, and in fact the control-flow method was never worse,
and was sometimes better.
Thus, the control-flow method is the winner, in terms of generating
less and more efficient code!
